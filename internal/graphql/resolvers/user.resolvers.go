package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"
	"learning/internal/graphql/models"
	"learning/internal/user"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input models.CreateUserInput) (*models.CreateUserPayload, error) {
	// Validate input
	var errors []*models.UserError

	if input.Name == "" {
		errors = append(errors, createUserError("name", "Name is required", models.ErrorCodeValidationError))
	}
	if input.Email == "" {
		errors = append(errors, createUserError("email", "Email is required", models.ErrorCodeValidationError))
	}
	if input.Phone == "" {
		errors = append(errors, createUserError("phone", "Phone is required", models.ErrorCodeValidationError))
	}

	if len(errors) > 0 {
		return &models.CreateUserPayload{
			User:   nil,
			Errors: errors,
		}, nil
	}

	// Create user using service
	userService := user.NewService(r.UserRepo)
	domainUser, err := userService.CreateUser(ctx, input.Name, input.Email, input.Phone)
	if err != nil {
		var errorCode models.ErrorCode
		if _, ok := err.(*user.ValidationError); ok {
			errorCode = models.ErrorCodeValidationError
		} else if err == user.ErrUserAlreadyExists {
			errorCode = models.ErrorCodeAlreadyExists
		} else {
			errorCode = models.ErrorCodeInternalError
		}

		return &models.CreateUserPayload{
			User:   nil,
			Errors: []*models.UserError{createUserError("", err.Error(), errorCode)},
		}, nil
	}

	// Convert to GraphQL model
	gqlUser := domainUserToGraphQL(domainUser)

	// Prime the cache for future lookups
	if r.Loaders != nil {
		r.Loaders.UserLoader.Prime(ctx, domainUser.ID, domainUser)
	}

	return &models.CreateUserPayload{
		User:   gqlUser,
		Errors: []*models.UserError{},
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input models.UpdateUserInput) (*models.UpdateUserPayload, error) {
	panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, input models.DeleteUserInput) (*models.DeleteUserPayload, error) {
	panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*models.User, error) {
	// Use DataLoader for efficient fetching
	if r.Loaders != nil {
		domainUser, err := r.Loaders.UserLoader.Load(ctx, id)
		if err != nil {
			if err == user.ErrUserNotFound {
				return nil, nil // Return nil for not found (GraphQL convention)
			}
			return nil, err
		}
		return domainUserToGraphQL(domainUser), nil
	}

	// Fallback to direct repository access
	domainUser, err := r.UserRepo.GetByID(ctx, id)
	if err != nil {
		if err == user.ErrUserNotFound {
			return nil, nil
		}
		return nil, err
	}

	return domainUserToGraphQL(domainUser), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, first *int, after *string, last *int, before *string, search *string) (*models.UserConnection, error) {
	// Set default pagination
	page := 1
	pageSize := 10

	if first != nil && *first > 0 {
		pageSize = *first
		if pageSize > 100 {
			pageSize = 100 // Max page size
		}
	}

	// Simple cursor-based pagination (in real implementation, decode cursor)
	if after != nil {
		// For simplicity, assume cursor is page number
		// In real implementation, decode base64 cursor
		page = 2 // Simplified
	}

	// Get users from service
	userService := user.NewService(r.UserRepo)
	domainUsers, total, err := userService.ListUsers(ctx, page, pageSize)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL models
	gqlUsers := domainUsersToGraphQL(domainUsers)

	// Create connection
	return createUserConnection(gqlUsers, total, page, pageSize), nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *userResolver) Orders(ctx context.Context, obj *user.User, first *int, after *string, last *int, before *string, status *order.OrderStatus) (*models.OrderConnection, error) {
	panic(fmt.Errorf("not implemented: Orders - orders"))
}
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }
type userResolver struct{ *Resolver }
*/
